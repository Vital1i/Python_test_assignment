import time
import random
from fastapi import FastAPI, HTTPException, Body, Depends
import os
from dotenv import load_dotenv
import autogen
from sqlalchemy.orm import Session

from utils.models import Candidate
from utils.prepopulate import prepopulate_candidates
from utils.schemas import CandidateResponse
from utils.storage import get_db, create_all_tables

load_dotenv()

app = FastAPI()
# Define LLM configuration
gpt4_config = {
    "cache_seed": int(time.time()) + random.randint(1, 1000),  # Change the cache_seed for different trials
    "temperature": 0.7,
    "config_list": [
        {"model": "gpt-3.5-turbo", "api_key": os.environ.get("OPENAI_API_KEY")}
    ],
    "timeout": 120,
}

# Define agents
initializer = autogen.UserProxyAgent(
    name="Init",
    code_execution_config={
        "use_docker": False
    },
)

question_agent = autogen.AssistantAgent(
    name="QuestionAgent",
    llm_config=gpt4_config,
    system_message="""You are the Question Agent. Given a job description, generate three interview questions to assess relevant skills. All question should be on theory.""",
)

evaluation_agent = autogen.AssistantAgent(
    name="EvaluationAgent",
    llm_config=gpt4_config,
    system_message="""You are the Evaluation Agent. Given a candidate's responses to questions, provide a score (1â€“5) and feedback for each response.""",
)

validator = autogen.AssistantAgent(
    name="Validator",
    llm_config=gpt4_config,
    system_message="""You are the Validator. Validate the scores and feedback, then generate a summary of the interview results.""",
)


def state_transition_question(last_speaker, groupchat):

    messages = groupchat.messages

    if last_speaker is initializer:
        # Init --> Question Agent
        return question_agent
    elif last_speaker is question_agent:
        # Question Agent --> Evaluation Agent
        return None

# State transition logic
def state_transition_answer(last_speaker, groupchat):
    messages = groupchat.messages

    if last_speaker is initializer:
        # Init --> Question Agent
        return evaluation_agent
    elif last_speaker is evaluation_agent:
        # Evaluation Agent --> Validator
        return validator
    elif last_speaker is validator:
        # Validator --> End
        return None


# GroupChat setup

groupchat = autogen.GroupChat(
    agents=[initializer, evaluation_agent,validator],
    messages=[],
    max_round=20,
    speaker_selection_method=state_transition_answer,
)

manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=gpt4_config)


# Initialize the chat
@app.post("/start_chat/")
async def start_chat():
    try:
        initializer_message = f"Job description: Junior Django Developer"

        groupchat_getting_messages = autogen.GroupChat(
            agents=[initializer, question_agent],
            messages=[],
            max_round=20,
            speaker_selection_method=state_transition_question,
        )

        manager1 = autogen.GroupChatManager(groupchat=groupchat_getting_messages, llm_config=gpt4_config)

        initializer.initiate_chat(
            manager1, message=initializer_message
        )
        # Extract initial questions generated
        questions = [
            msg["content"] for msg in groupchat_getting_messages.messages if msg["name"] == "QuestionAgent"
        ]
        print(i for i in groupchat_getting_messages.messages)
        return {"message": "Chat started successfully", "questions": questions}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Continue the chat
@app.post("/continue_chat")
async def continue_chat(questions: list[str] = Body(...), responses: list[str] = Body(...)):
    try:
        # Send the user responses along with the questions
        # Both questions and responses will be used in the conversation
        user_message = (f"Response to question ('{questions[0]}'): {responses[0]},"
                        f"Response to question ('{questions[1]}'): {responses[1]},"
                        f"Response to question ('{questions[2]}'): {responses[2]},")
        initializer.initiate_chat(manager, message=user_message)

        # Now, run the group chat until it reaches the Validator
        print(i for i in groupchat.messages)
        # Extract the final summary generated by the Validator
        final_summary = [
            msg["content"] for msg in groupchat.messages if msg["name"] == "Validator"
        ][-1]

        return {"message": "Interview completed", "summary": final_summary}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.on_event("startup")
async def startup_event():
    # Pre-populate the candidates in the database
    db = next(get_db())
    prepopulate_candidates(db)

    # Create tables if they don't exist yet
    create_all_tables()


@app.get("/candidates/", response_model=list[CandidateResponse])
async def get_candidates(db: Session = Depends(get_db)):
    candidates = db.query(Candidate).all()
    return candidates


@app.get("/candidates/{candidate_id}", response_model=CandidateResponse)
async def get_candidate(candidate_id: str, db: Session = Depends(get_db)):
    candidate = db.query(Candidate).filter(Candidate.candidate_id == candidate_id).first()
    if candidate is None:
        raise HTTPException(status_code=404, detail="Candidate not found")
    return candidate


